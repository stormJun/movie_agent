# GraphRAG 项目领域适配指南

## 目录

1. [项目概述](#项目概述)
2. [架构说明](#架构说明)
3. [领域适配流程](#领域适配流程)
4. [数据源准备](#数据源准备)
5. [Schema 设计方法](#schema-设计方法)
6. [典型领域案例](#典型领域案例)
7. [实施步骤](#实施步骤)
8. [常见问题](#常见问题)
9. [最佳实践](#最佳实践)

---

## 项目概述

### 什么是 GraphRAG

GraphRAG（Graph Retrieval-Augmented Generation）是一种结合知识图谱和大语言模型的智能问答系统，通过以下特点提供高质量的知识服务：

- **知识图谱构建**：从文档中自动抽取实体和关系，构建结构化知识网络
- **多智能体协作**：Plan-Execute-Report 架构实现复杂问题的分解与推理
- **多种检索策略**：本地搜索、全局搜索、混合搜索、深度研究
- **可解释性强**：提供证据链追踪和推理过程可视化

### 适用场景

- ✅ 需要准确回答的垂直领域问答
- ✅ 需要多步推理的复杂问题
- ✅ 需要证据支撑的专业咨询
- ✅ 文档量大、人工检索困难的场景

---

## 架构说明

### 核心组件

```
backend/graphrag_agent/
├── agents/              # 智能体系统
│   ├── base.py         # BaseAgent（所有Agent的基类）
│   ├── naive_rag_agent.py    # 基础向量检索
│   ├── graph_agent.py        # 图结构推理
│   ├── hybrid_agent.py       # 混合搜索
│   ├── deep_research_agent.py # 深度研究
│   └── fusion_agent.py       # 多智能体协作（最强）
│
├── graph/               # 知识图谱构建
│   ├── extraction/     # LLM 实体关系抽取
│   ├── processing/     # 实体消歧与对齐
│   ├── indexing/       # 向量索引（实体+chunk）
│   └── core/           # Neo4j 连接管理
│
├── search/              # 检索策略
│   ├── local_search.py     # 实体中心检索
│   ├── global_search.py    # 社区聚合检索
│   └── tool/               # 检索工具
│
├── pipelines/ingestion/ # 文档处理（多格式支持）
├── cache_manager/       # 双层缓存系统
├── community/           # 社区检测与摘要
└── evaluation/          # 评估指标（20+）
```

### 数据流转

```
原始文档 (files/)
    ↓
文档摄取 (pipelines/ingestion/)
    ↓
文本分块 (chunking)
    ↓
实体关系抽取 (LLM Extraction)
    ↓
实体消歧对齐 (Disambiguation & Alignment)
    ↓
图谱构建 (Neo4j)
    ↓
向量索引 (Entity Index + Chunk Index)
    ↓
社区检测 (Leiden/SLLPA)
    ↓
知识服务 (Multi-Agent Query)
```

---

## 领域适配流程

### 核心适配要素

将 GraphRAG 系统适配到新领域，需要修改以下内容：

| 要素 | 文件位置 | 说明 |
|------|----------|------|
| **知识库主题** | `backend/config/rag_semantics.py`（或 `.env`） | `KB_NAME`, `GRAPH_THEME` |
| **实体类型** | `backend/config/rag_semantics.py`（或 `.env`） | `GRAPH_ENTITY_TYPES` |
| **关系类型** | `backend/config/rag_semantics.py`（或 `.env`） | `GRAPH_RELATIONSHIP_TYPES` |
| **示例问题** | `backend/config/rag_semantics.py`（或 `.env`） | `FRONTEND_EXAMPLES` |
| **原始文档** | `files/` 目录 | 支持多种格式 |
| **检索提示** | `backend/config/prompts/` | 可选优化 |

### 三层配置体系

```
1. `.env` → 运行时参数（API密钥、性能调优、语义默认值）
2. `backend/config/rag_semantics.py` / `backend/config/rag.py` → 领域/RAG 语义（实体、关系、主题、示例问题等）
3. 配置入口（按职责拆分）
   - `backend/config/settings.py`：服务侧运行参数与开关
   - `backend/infrastructure/config/settings.py`：基础设施侧配置（Neo4j/LLM/缓存/路由阈值等）
```

---

## 数据源准备

### 支持的文档格式

| 格式 | 扩展名 | 适用场景 |
|------|--------|----------|
| 纯文本 | `.txt` | 简单文档、日志 |
| PDF | `.pdf` | 正式文档、报告 |
| Markdown | `.md` | 技术文档、Wiki |
| Word文档 | `.docx`, `.doc` | Office文档 |
| 表格 | `.csv` | 结构化数据 |
| 结构化数据 | `.json`, `.yaml` | 配置、元数据 |

### 数据获取方式

#### 方式一：开源数据集

```bash
# 直接下载开源数据
git clone <数据集仓库>
cp -r <数据集>/* /path/to/graph-rag-agent/files/
```

#### 方式二：文档转换

```python
# 将结构化数据转为文本
import json

def json_to_markdown(data, output_file):
    """将 JSON 数据转换为 Markdown"""
    with open(output_file, 'w') as f:
        f.write(f"# {data['title']}\n\n")
        f.write(f"**描述**: {data['description']}\n\n")
        f.write("## 关键信息\n\n")
        for key, value in data.items():
            f.write(f"- **{key}**: {value}\n")
```

#### 方式三：网页爬取（注意遵守规则）

```python
import requests
from bs4 import BeautifulSoup

def scrape_docs(url_list, output_dir):
    """爬取文档网站内容"""
    for url in url_list:
        # 1. 检查 robots.txt
        # 2. 设置合理的 User-Agent
        # 3. 添加延迟避免过载
        response = requests.get(url, headers={'User-Agent': 'Research/Bot'})
        # 解析并保存
```

### 数据质量要求

- ✅ **结构清晰**：有明确的章节和标题
- ✅ **内容完整**：覆盖领域的主要知识点
- ✅ **格式统一**：便于文本处理
- ✅ **数量充足**：建议至少 50+ 文档或 10万+ 字符
- ❌ 避免纯列表、表格过多的数据

---

## Schema 设计方法

### 设计原则

1. **实体类型**：领域内的核心概念
2. **关系类型**：实体间的交互方式
3. **层次合理**：3-10 个实体类型，5-15 个关系类型
4. **实用导向**：以问答需求为出发点

### 设计步骤

#### 第一步：列出领域核心概念

**示例：医疗领域**

| 概念类别 | 具体概念 |
|----------|----------|
| 疾病相关 | 疾病、症状、并发症 |
| 检查相关 | 检查项目、检验指标 |
| 治疗相关 | 药品、治疗方法 |
| 医学概念 | 解剖部位、科室 |

#### 第二步：定义关系类型

**关系命名模式**

- **动词关系**：包含、依赖、引起、治疗
- **属性关系**：位于、属于、具有
- **约束关系**：禁忌、互斥、限制

#### 第三步：验证覆盖度

检查示例问题是否能被 Schema 覆盖：

```
问题：头痛发热是什么病？
↓
解析：头痛(症状) + 发热(症状) → ?疾病
↓
需要关系：疾病--症状表现-->症状 ✓
```

### Schema 设计模板

```python
# 领域名称：_____________
# 知识库主题：_____________

# 实体类型
entity_types = [
    # 核心实体（3-5个）
    "_________",
    "_________",
    "_________",

    # 辅助实体（2-5个）
    "_________",
    "_________",
]

# 关系类型
relationship_types = [
    # 主要关系（5-10个）
    "_________",  # 实体A --关系--> 实体B
    "_________",
    "_________",

    # 次要关系（2-5个）
    "_________",
    "_________",
]

# 示例问题（覆盖主要场景）
examples = [
    "_________",
    "_________",
    "_________",
]
```

---

## 典型领域案例

### 案例一：产品技术文档（FastAPI）

#### 数据源

- FastAPI 官方文档（Markdown）
- 官方教程和示例代码
- 社区贡献的指南

#### Schema 设计

```python
KB_NAME = "FastAPI技术文档"
theme = "FastAPI Web框架技术文档"

entity_types = [
    "模块",           # Routing, Dependencies, Security
    "类",            # FastAPI, APIRouter, Request
    "函数",          # get(), post(), decorator
    "参数",          # response_model, status_code
    "配置",          # CORS, 中间件
    "概念",          # Dependency Injection, Pydantic
    "数据类型",      # str, int, List, Dict
    "异常",          # HTTPException
]

relationship_types = [
    "包含",          # 模块包含类
    "继承",          # 类继承
    "导入",          # 需要导入
    "配置",          # 配置对象
    "参数类型",      # 参数的类型
    "返回类型",      # 返回值类型
    "抛出",          # 可能抛出的异常
    "示例",          # 使用示例
    "依赖",          # 前置依赖
]

examples = [
    "如何定义一个 GET 请求接口？",
    "如何接收路径参数和查询参数？",
    "FastAPI 的依赖注入如何使用？",
    "如何配置 CORS 跨域？",
    "如何进行请求体验证？",
]
```

#### 文档结构建议

```
files/
├── tutorial/
│   ├── first-steps.md
│   ├── path-params.md
│   ├── query-params.md
│   └── ...
├── advanced/
│   ├── dependencies.md
│   ├── security.md
│   └── ...
└── reference/
    ├── fastapi.md
    ├── apirouter.md
    └── ...
```

---

### 案例二：医疗健康知识

#### 数据源

| 数据源 | 内容 | 许可 |
|--------|------|------|
| **CMeKG** | 中文医学知识图谱 | MIT |
| **MeSH中文** | 医学主题词表 | 开放 |
| **丁香园** | 疾病百科、药品信息 | 部分开放 |
| **ICD-10** | 国际疾病分类 | WHO |

#### Schema 设计

```python
KB_NAME = "中文医疗知识库"
theme = "临床诊疗知识图谱"

entity_types = [
    # 疾病相关
    "疾病",
    "症状",
    "并发症",

    # 检查相关
    "检查项目",       # 血常规、CT、MRI
    "检验指标",       # 白细胞、血压

    # 治疗相关
    "药品",
    "治疗方法",       # 手术、药物治疗
    "治疗方案",

    # 医学概念
    "解剖部位",       # 心脏、肺部
    "医学概念",       # 炎症、感染
    "科室",

    # 风险因素
    "危险因素",       # 吸烟、高血压
    "禁忌症",
    "不良反应",
]

relationship_types = [
    # 疾病与症状
    "症状表现",       # 疾病 -> 症状
    "并发",           # 疾病 -> 并发症
    "易感",           # 危险因素 -> 疾病

    # 诊断相关
    "需要检查",       # 疾病 -> 检查项目
    "指标异常",       # 疾病 -> 检验指标
    "鉴别诊断",       # 疾病 <-> 疾病

    # 治疗相关
    "适用药物",       # 疾病 -> 药品
    "禁忌药物",       # 疾病 -> 药品（不能用）
    "治疗方法",       # 疾病 -> 治疗方法
    "药物组成",       # 治疗方案 -> 药品

    # 药品关系
    "适应症",         # 药品 -> 疾病
    "不良反应",       # 药品 -> 不良反应
    "药物相互作用",   # 药品 <-> 药品
    "成分",           # 药品 -> 成分

    # 其他
    "位于",           # 症状/疾病 -> 解剖部位
    "属于科室",       # 疾病/检查 -> 科室
    "因果关系",       # 危险因素 -> 疾病
]

examples = [
    # 症状自查
    "头痛发热可能是什么病？",
    "咳嗽伴胸痛应该考虑哪些疾病？",

    # 检查诊断
    "肺炎需要做哪些检查？",
    "白细胞升高说明什么？",

    # 药物治疗
    "感冒应该吃什么药？",
    "阿司匹林的禁忌症有哪些？",

    # 就医指导
    "头痛应该挂什么科？",
]
```

#### 数据处理注意事项

⚠️ **医疗数据特殊要求**：
- 确保数据来源权威（WHO、国家卫健委、官方医学指南）
- 添加免责声明："仅供参考，不作为医疗诊断依据"
- 定期更新（医学知识更新快）
- 隐私保护（确保无患者敏感信息）

---

### 案例三：云服务文档（阿里云）

#### Schema 设计

```python
KB_NAME = "阿里云产品文档"
theme = "阿里云服务使用指南"

entity_types = [
    "产品服务",       # ECS, RDS, OSS, SLB
    "API接口",       # CreateInstance, DescribeInstances
    "参数",          # InstanceType, RegionId
    "错误码",        # InvalidParameter, Unauthorized
    "计费项",        # 流量费、存储费、请求次数
    "使用场景",      # 网站托管、视频处理、大数据
    "地域",          # cn-hangzhou, cn-beijing
    "计费模式",      # 按量付费、包年包月
]

relationship_types = [
    "属于",          # API属于产品
    "依赖",          # 产品间依赖
    "参数要求",      # API需要的参数
    "返回",          # 返回的错误码
    "收费",          # 计费规则
    "适用",          # 使用场景
    "支持",          # 产品支持的功能
    "限制",          # 使用限制
]

examples = [
    "如何创建一个 ECS 实例？",
    "OSS 如何设置跨域访问？",
    "RDS 数据库如何备份？",
    "SLB 负载均衡如何配置？",
    "如何查看账单明细？",
]
```

---

## 实施步骤

### 完整迁移流程

#### 第一步：准备环境

```bash
# 1. 确认环境已配置
conda activate graphrag
cd /path/to/graph-rag-agent

# 2. 检查 Neo4j 运行状态
docker ps | grep neo4j

# 3. 检查 .env 配置
cat .env | grep OPENAI_API_KEY
cat .env | grep NEO4J_URI
```

#### 第二步：准备数据

```bash
# 1. 创建数据目录
mkdir -p files/new_domain

# 2. 获取数据（选择一种方式）
# 方式A: 下载数据集
wget <数据集URL>
unzip <数据集>.zip -d files/new_backend/domain/

# 方式B: 克隆仓库
git clone <repo> files/new_backend/domain/

# 方式C: 手动放置
cp /path/to/docs/* files/new_backend/domain/

# 3. 检查数据
ls -lh files/new_backend/domain/
```

#### 第三步：修改配置

编辑 `backend/graphrag_agent/config/settings.py`：

```python
# ===== 知识库与系统参数 =====
KB_NAME = "你的知识库名称"
theme = "你的知识图谱主题"

# ===== 实体类型 =====
entity_types = [
    "实体1",
    "实体2",
    "实体3",
    # ... 根据领域设计
]

# ===== 关系类型 =====
relationship_types = [
    "关系1",
    "关系2",
    "关系3",
    # ... 根据领域设计
]

# ===== 示例问题 =====
examples = [
    "问题1",
    "问题2",
    "问题3",
]
```

#### 第四步：清空旧数据

```bash
# 1. 备份旧配置（可选）
cp backend/graphrag_agent/config/settings.py settings.py.bak
mv file_registry.json file_registry.json.bak

# 2. 清空 Neo4j 图谱
docker exec -it neo4j cypher-shell -u neo4j -p 12345678 \
  "MATCH (n) DETACH DELETE n"

# 3. 删除缓存和索引
rm -rf cache/
```

#### 第五步：重新构建图谱

```bash
# 运行完整构建流程
python -m backend.infrastructure.integrations.build.main
```

**预期输出**：
```
开始知识图谱处理流程
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 100%

步骤 0: 清除所有旧索引 ✓
步骤 1: 构建基础图谱 ✓
  - 文档摄取: 150 个文件
  - 实体抽取: 2,345 个实体
  - 关系抽取: 5,678 个关系

步骤 2: 构建实体索引和社区 ✓
  - 实体消歧: 95.2% 准确率
  - 社区检测: 45 个社区

步骤 3: 构建Chunk索引 ✓
  - 文本分块: 1,234 个chunks
  - 向量化完成

知识图谱处理流程完成 ✓
```

#### 第六步：测试验证

```bash
cd test/

# 编辑测试脚本，添加你的领域问题
vim search_with_stream.py

# 运行测试
python search_with_stream.py
```

#### 第七步：启动服务

```bash
# 后端
python -m backend.server.main

# 新开终端，前端
streamlit run frontend/app.py
```

访问 `http://localhost:8501` 验证效果。

---

## 常见问题

### Q1: 实体抽取效果不好怎么办？

**原因分析**：
- LLM 模型对领域不熟悉
- 文档格式不规范
- 实体类型定义不清晰

**解决方案**：

1. **更换更强的模型**
```env
# 在 .env 中
OPENAI_LLM_MODEL=gpt-4o  # 或其他强模型
```

2. **优化实体类型定义**
```python
# 避免过于宽泛
# ❌ 错误示例
entity_types = ["概念", "事物"]

# ✅ 正确示例
entity_types = ["疾病", "症状", "药品", "检查项目"]
```

3. **提供更多示例**
在 LLM prompt 中添加 few-shot 示例（修改 `backend/config/prompts/`）

---

### Q2: 知识图谱构建太慢

**优化方案**：

```env
# 在 .env 中调整并发参数
MAX_WORKERS=8              # 增加线程数
BATCH_SIZE=200             # 增大批处理
LLM_BATCH_SIZE=10          # LLM 批量请求
EMBEDDING_BATCH_SIZE=128   # 向量批处理
```

```python
# 减少实体类型数量（降低抽取复杂度）
entity_types = ["核心实体1", "核心实体2", "核心实体3"]
# 避免超过 10 个实体类型
```

---

### Q3: 问答回答不准确

**诊断步骤**：

1. **检查图谱质量**
```bash
# 访问 Neo4j 浏览器
open http://localhost:7474

# 执行查询
MATCH (n) RETURN n LIMIT 25
```

2. **测试检索效果**
```python
# 测试不同的检索策略
# Local Search: 实体中心
# Global Search: 社区聚合
# Hybrid Search: 混合模式
```

3. **调整相似度阈值**
```env
# 在 .env 中
SIMILARITY_THRESHOLD = 0.85  # 提高阈值更严格
```

4. **切换 Agent**
```python
# 尝试不同的 Agent
agent_type = "fusion_agent"  # 最强但慢
agent_type = "graph_agent"   # 图推理
agent_type = "hybrid_agent"  # 混合检索
```

---

### Q4: 内存不足

**解决方案**：

```env
# 减少缓存占用
CACHE_MAX_MEMORY_SIZE=50     # MB
CACHE_MAX_DISK_SIZE=500      # MB

# 调整 GDS 内存
GDS_MEMORY_LIMIT=4           # GB
```

```bash
# 清理 Neo4j 缓存
docker exec neo4j cypher-shell "CALL dbms.clearQueryCaches()"

# 重启 Neo4j
docker restart neo4j
```

---

### Q5: 增量更新如何使用？

```bash
# 单次增量更新
python -m backend.infrastructure.integrations.build.incremental_update --once

# 守护进程模式
python -m backend.infrastructure.integrations.build.incremental_update --daemon
```

**增量更新机制**：
- 基于 `file_registry.json` 追踪文件变化
- 支持新增、删除、修改文件
- 自动处理冲突（可配置策略）

---

## 最佳实践

### 1. 数据准备

✅ **DO**:
- 使用结构化清晰的文档
- 保持格式统一（Markdown 优先）
- 提供充足的样本数据（50+ 文件）
- 定期更新数据源

❌ **DON'T**:
- 避免纯列表或表格
- 避免内容过少（< 10 个文档）
- 避免格式混乱

### 2. Schema 设计

✅ **DO**:
- 3-10 个实体类型
- 5-15 个关系类型
- 从问答需求反推设计
- 逐步迭代优化

❌ **DON'T**:
- 避免过多类型（> 15 个实体）
- 避免过于抽象的概念
- 避免重复的关系类型

### 3. 性能优化

✅ **DO**:
- 根据硬件调整并发参数
- 使用双层缓存
- 启用向量相似度缓存

❌ **DON'T**:
- 避免单线程处理大数据集
- 避免禁用所有缓存

### 4. 质量保证

✅ **DO**:
- 使用测试集验证效果
- 定期检查图谱质量
- 收集用户反馈

❌ **DON'T**:
- 避免未经测试就上线
- 避免忽略幻觉问题

### 5. 持续维护

✅ **DO**:
- 定期更新文档和图谱
- 监控系统性能
- 优化示例问题

❌ **DON'T**:
- 避免一次构建后不再更新

---

## 附录

### A. 配置文件完整示例

```env
# .env 完整配置（关键部分）

# ===== LLM 配置 =====
OPENAI_API_KEY=sk-xxx
OPENAI_BASE_URL=http://localhost:13000/v1
OPENAI_EMBEDDINGS_MODEL=text-embedding-3-large
OPENAI_LLM_MODEL=gpt-4o

# ===== Neo4j 配置 =====
NEO4J_URI=neo4j://localhost:7687
NEO4J_USERNAME=neo4j
NEO4J_PASSWORD=12345678

# ===== 性能调优 =====
MAX_WORKERS=4
BATCH_SIZE=100
ENTITY_BATCH_SIZE=50
CHUNK_BATCH_SIZE=100
EMBEDDING_BATCH_SIZE=64
LLM_BATCH_SIZE=5

# ===== 文本处理 =====
CHUNK_SIZE=500
CHUNK_OVERLAP=100
SIMILARITY_THRESHOLD=0.85

# ===== GDS 配置 =====
GDS_MEMORY_LIMIT=6
GDS_CONCURRENCY=4
```

### B. 常用命令速查

```bash
# 环境管理
conda activate graphrag
conda deactivate

# Neo4j 操作
docker compose up -d              # 启动
docker compose down               # 停止
docker exec -it neo4j bash        # 进入容器

# 图谱构建
python -m backend.infrastructure.integrations.build.main           # 全量
python -m backend.infrastructure.integrations.build.incremental_update --once  # 增量

# 测试
cd test/
python search_with_stream.py      # 流式测试
python search_without_stream.py   # 非流式

# 服务启动
python -m backend.server.main             # 后端
streamlit run frontend/app.py     # 前端

# 清理
rm -rf cache/
rm file_registry.json
docker exec neo4j cypher-shell -u neo4j -p 12345678 "MATCH (n) DETACH DELETE n"
```

### C. 数据源推荐清单

| 领域 | 推荐数据源 | 格式 | 许可 |
|------|-----------|------|------|
| **技术文档** | FastAPI, Vue.js | MD | MIT |
| **医疗健康** | CMeKG, MeSH | JSON | 开放 |
| **云服务** | 阿里云, AWS | HTML/MD | 文档 |
| **法律** | 裁判文书网 | HTML | 公开 |
| **金融** | 巨潮资讯网 | PDF | 公开 |
| **教育** | 政策文件 | PDF | 公开 |

### D. 问题诊断清单

当系统出现问题时，按以下顺序检查：

- [ ] `.env` 配置是否正确（API Key、Neo4j URI）
- [ ] Neo4j 是否正常运行（`docker ps`）
- [ ] 文档是否已放入 `files/` 目录
- [ ] Schema 设计是否合理（实体/关系类型）
- [ ] LLM 模型是否可用（测试 API 调用）
- [ ] 缓存是否需要清理
- [ ] 日志中的错误信息

---

## 版本信息

- **文档版本**: v1.0
- **项目版本**: 基于当前 master 分支
- **更新日期**: 2025-12-26
- **维护者**: GraphRAG Agent Team

---

## 参考资源

- **项目仓库**: [https://github.com/1517005260/graph-rag-agent](https://github.com/1517005260/graph-rag-agent)
- **GraphRAG 论文**: Microsoft Research GraphRAG
- **Neo4j 文档**: [https://neo4j.com/docs/](https://neo4j.com/docs/)
- **LangGraph 文档**: [https://langchain-ai.github.io/langgraph/](https://langchain-ai.github.io/langgraph/)

---

**版权声明**: 本文档基于 GraphRAG Agent 项目整理，遵循项目原许可证。
