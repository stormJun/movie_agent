# 电影业务问题分型 - 技术实现版

## 目标
为每类问题定义：
1. **触发模式**：如何识别这类问题
2. **证据需求**：需要检索什么数据
3. **输出结构**：返回什么格式
4. **实现策略**：用什么Agent和检索策略

---

## 类型 1：事实查询（单点）

### 1.1 触发模式
**用户意图**：获取电影的单一事实信息

**问题示例**：
- "《星际穿越》的导演是谁？"
- "《黑暗骑士》哪一年上映的？"
- "《复仇者联盟4》的片长是多少？"
- "《寄生虫》的评分是多少？"

**关键词特征**：
```python
FACT_QUERY_PATTERNS = [
    r"(.*?)的(导演|主演|上映年份|片长|评分|地区|语言)是?",
    r"(.*?)谁导演的",
    r"(.*?)什么时候上映",
    r"(.*?)多长时间",
    r"(.*?)评分多少"
]

FACT_ATTRIBUTES = [
    "director", "cast", "year", "duration", "rating",
    "country", "language", "genre", "budget", "box_office"
]
```

### 1.2 证据需求

```python
@dataclass
class FactQueryEvidence:
    """事实查询的证据需求"""

    # 必需：目标电影实体
    movie_entity: Dict[str, Any]  # {name, year, id}

    # 必需：查询的属性
    target_attribute: str  # "director", "rating", etc.

    # 可选：辅助属性（用于验证）
    auxiliary_attributes: List[str]

    # 可选：实时数据（评分、票房可能变化）
    realtime_data: bool

    # 来源追溯
    sources: List[str]  # ["kg", "tmdb", "wiki"]

# 示例
evidence = FactQueryEvidence(
    movie_entity={"name": "星际穿越", "year": 2014, "tmdb_id": 157336},
    target_attribute="rating",
    auxiliary_attributes=["title", "year"],
    realtime_data=True,
    sources=["kg", "tmdb"]
)
```

### 1.3 输出结构

```python
@dataclass
class FactQueryOutput:
    """事实查询的输出结构"""

    # 问题理解
    query_understanding: Dict[str, Any]
    """
    {
        "movie": "星际穿越",
        "attribute": "rating",
        "question_type": "fact_query"
    }
    """

    # 主要答案
    answer: str
    """
    "《星际穿越》（2014）的IMDb评分是8.6，豆瓣评分9.3"
    """

    # 关键字段（结构化）
    key_fields: Dict[str, Any]
    """
    {
        "movie_title": "星际穿越",
        "year": 2014,
        "imdb_rating": 8.6,
        "douban_rating": 9.3,
        "rating_count": 2100000
    }
    """

    # 数据来源
    sources: List[Dict[str, str]]
    """
    [
        {"type": "kg", "description": "知识图谱"},
        {"type": "tmdb", "url": "https://..."}
    ]
    """

    # 置信度
    confidence: float  # 0.95

# JSON输出示例
{
    "query_understanding": {
        "movie": "星际穿越",
        "attribute": "rating",
        "question_type": "fact_query"
    },
    "answer": "《星际穿越》（2014）的IMDb评分是8.6，豆瓣评分9.3，超过210万人评分。",
    "key_fields": {
        "movie_title": "星际穿越",
        "year": 2014,
        "imdb_rating": 8.6,
        "douban_rating": 9.3,
        "rating_count": 2100000
    },
    "sources": [
        {"type": "kg", "description": "电影知识图谱"},
        {"type": "tmdb", "url": "https://www.themoviedb.org/movie/157336"}
    ],
    "confidence": 0.95
}
```

### 1.4 实现策略

```python
# Agent选择：GraphAgent (轻量级)
# 检索策略：实体属性查询

class FactQueryAgent(BaseAgent):
    def retrieve_with_trace(self, query: str) -> FactQueryOutput:
        # Step 1: 解析查询
        parsed = self.parse_fact_query(query)
        # -> {"movie": "星际穿越", "attribute": "rating"}

        # Step 2: 实体识别
        movie_entity = self.identify_movie(parsed["movie"])
        # -> {"name": "星际穿越", "year": 2014, "id": "movie_123"}

        # Step 3: 属性检索
        if parsed["attribute"] in ["rating", "box_office"]:
            # 实时数据：从TMDB查询
            value = self.query_tmdb(movie_entity, parsed["attribute"])
        else:
            # 静态数据：从KG查询
            value = self.query_kg_property(movie_entity, parsed["attribute"])

        # Step 4: 格式化输出
        return self.format_fact_output(movie_entity, parsed["attribute"], value)
```

---

## 类型 2：人物相关

### 2.1 触发模式
**用户意图**：获取某导演/演员的作品信息

**问题示例**：
- "诺兰导演过哪些电影？"
- "梁朝伟的代表作有哪些？"
- "诺兰和莱昂纳多合作过几次？"
- "漫威电影里小罗伯特·唐尼演过哪些？"

**关键词特征**：
```python
PERSON_QUERY_PATTERNS = [
    r"(.*?)导演过哪些电影",
    r"(.*?)的作品列表",
    r"(.*?)的代表作",
    r"(.*?)和(.*?)的合作",
    r"(.*?)在(.*?)系列里演过"
]

PERSON_ROLES = ["director", "actor", "writer", "producer"]
```

### 2.2 证据需求

```python
@dataclass
class PersonQueryEvidence:
    """人物查询的证据需求"""

    # 必需：人物实体
    person_entity: Dict[str, Any]
    """
    {
        "name": "克里斯托弗·诺兰",
        "role": "director",
        "id": "person_123"
    }
    """

    # 必需：查询类型
    query_type: Literal["filmography", "collaborations", "masterpieces"]

    # 可选：约束条件
    constraints: Dict[str, Any]
    """
    {
        "year_range": [2000, 2024],
        "min_rating": 8.0,
        "genres": ["科幻"],
        "role": "director"
    }
    """

    # 可选：合作人物
    collaborator: Optional[Dict[str, Any]] = None

    # 分页
    page: int = 1
    page_size: int = 20

# 示例：查询诺兰的电影作品
evidence = PersonQueryEvidence(
    person_entity={"name": "克里斯托弗·诺兰", "role": "director"},
    query_type="filmography",
    constraints={
        "min_rating": 7.0,
        "sort_by": "year"  # 按年份排序
    },
    page=1,
    page_size=20
)
```

### 2.3 输出结构

```python
@dataclass
class PersonQueryOutput:
    """人物查询的输出结构"""

    # 查询理解
    query_understanding: Dict[str, Any]
    """
    {
        "person": "克里斯托弗·诺兰",
        "role": "director",
        "query_type": "filmography",
        "constraints": {"min_rating": 7.0}
    }
    """

    # 人物基本信息
    person_info: Dict[str, Any]
    """
    {
        "name": "克里斯托弗·诺兰",
        "chinese_name": "克里斯托弗·诺兰",
        "role": "director",
        "birth_date": "1970-07-30",
        "nationality": "英国",
        "style_tags": ["非线性叙事", "烧脑", "科幻"]
    }
    """

    # 作品列表（核心输出）
    filmography: List[Dict[str, Any]]
    """
    [
        {
            "rank": 1,
            "movie": {
                "title": "奥本海默",
                "year": 2023,
                "rating": 8.9,
                "genres": ["传记", "剧情", "历史"]
            },
            "role": "导演, 编剧",
            "reason": "诺兰最新作品，奥斯卡最佳影片"
        },
        {
            "rank": 2,
            "movie": {
                "title": "星际穿越",
                "year": 2014,
                "rating": 8.6,
                "genres": ["科幻", "冒险", "剧情"]
            },
            "role": "导演, 编剧",
            "reason": "诺兰科幻代表作"
        },
        ...
    ]
    """

    # 统计信息
    statistics: Dict[str, Any]
    """
    {
        "total_works": 12,
        "avg_rating": 8.3,
        "highest_rated": {"title": "盗梦空间", "rating": 8.8},
        "most_recent": {"title": "奥本海默", "year": 2023},
        "genre_distribution": {"科幻": 5, "剧情": 7, "动作": 3}
    }
    """

    # 分页信息
    pagination: Dict[str, Any]
    """
    {
        "current_page": 1,
        "page_size": 20,
        "total_count": 12,
        "total_pages": 1,
        "has_next": false
    }
    """

    # 关联作品证据（用于推荐）
    related_works: List[Dict[str, Any]]
    """
    [
        {
            "type": "similar_director",
            "description": "类似风格的导演",
            "works": ["维伦纽瓦的《沙丘》", "库布里克的《2001太空漫游》"]
        }
    ]
    """

    # 数据来源
    sources: List[Dict[str, str]]

# JSON输出示例
{
    "query_understanding": {
        "person": "克里斯托弗·诺兰",
        "role": "director",
        "query_type": "filmography"
    },
    "person_info": {
        "name": "克里斯托弗·诺兰",
        "birth_date": "1970-07-30",
        "nationality": "英国"
    },
    "filmography": [
        {
            "rank": 1,
            "movie": {"title": "奥本海默", "year": 2023, "rating": 8.9},
            "role": "导演, 编剧"
        },
        {
            "rank": 2,
            "movie": {"title": "星际穿越", "year": 2014, "rating": 8.6},
            "role": "导演, 编剧"
        }
    ],
    "statistics": {
        "total_works": 12,
        "avg_rating": 8.3
    },
    "pagination": {
        "current_page": 1,
        "total_count": 12
    }
}
```

### 2.4 实现策略

```python
# Agent选择：GraphAgent + 过滤器
# 检索策略：实体中心查询 + 关系遍历

class PersonQueryAgent(BaseAgent):
    def retrieve_with_trace(self, query: str) -> PersonQueryOutput:
        # Step 1: 解析查询
        parsed = self.parse_person_query(query)
        # -> {"person": "诺兰", "query_type": "filmography"}

        # Step 2: 人物实体识别
        person = self.identify_person(parsed["person"])
        # -> {"name": "克里斯托弗·诺兰", "id": "person_123"}

        # Step 3: 查询作品关系
        if parsed["query_type"] == "filmography":
            # KG查询：Person -[导演]-> Movie
            works = self.query_kg_relationships(
                person,
                relationship_type="导演",
                constraints=parsed.get("constraints")
            )
        elif parsed["query_type"] == "collaborations":
            # KG查询：Person -[合作]-> Person -[作品]-> Movie
            works = self.query_collaborations(person, parsed.get("collaborator"))

        # Step 4: 排序和分页
        sorted_works = self.sort_and_paginate(works, parsed.get("sort_by"))

        # Step 5: 统计信息
        stats = self.compute_statistics(sorted_works)

        # Step 6: 关联作品（用于推荐）
        related = self.find_related_works(person, sorted_works)

        return PersonQueryOutput(
            filmography=sorted_works,
            statistics=stats,
            related_works=related
        )
```

---

## 类型 3：推荐

### 3.1 触发模式
**用户意图**：根据偏好/场景/约束获取推荐

**问题示例**：
- "给我推荐几部电影"
- "适合周末放松的喜剧电影"
- "8分以上的科幻片，不要太长的"
- "诺兰风格的电影推荐"
- "我和女朋友一起看，求推荐"

**关键词特征**：
```python
RECOMMENDATION_PATTERNS = [
    r"推荐.*电影",
    r"好看的(.*?)电影",
    r"适合(.*?)的(.*?)电影",
    r"(.*?)分以上",
    r"不要(.*?)",
    r"我和(.*?)一起看"
]

RECOMMENDATION_SCENARIOS = [
    "周末放松", "约会", "家庭观看", "熬夜",
    "治愈", "烧脑", "刺激", "轻松"
]

RECOMMENDATION_CONSTRAINTS = [
    "min_rating", "max_duration", "year_range",
    "genres", "countries", "languages", "platform"
]
```

### 3.2 证据需求

```python
@dataclass
class RecommendationEvidence:
    """推荐的证据需求"""

    # 必需：用户画像
    user_profile: Optional[Dict[str, Any]] = None
    """
    {
        "user_id": "123",
        "favorite_genres": ["科幻", "悬疑"],
        "favorite_directors": ["诺兰"],
        "recently_watched": ["星际穿越", "黑暗骑士"],
        "ratings": {"肖申克的救赎": 5, "阿甘正传": 5},
        "watchlist": ["盗梦空间", "信条"],
        "excluded": ["已看过的", "不想看的"]
    }
    """

    # 可选：场景识别
    scenario: Optional[str] = None
    """
    "周末放松", "约会", "家庭观看", "治愈"
    """

    # 可选：硬性约束
    constraints: Optional[Dict[str, Any]] = None
    """
    {
        "min_rating": 8.0,
        "max_duration": 120,
        "year_range": [2020, 2024],
        "genres": ["科幻"],
        "countries": ["美国"],
        "exclude_genres": ["恐怖"]
    }
    """

    # 推荐策略
    strategies: List[str] = field(default_factory=lambda: [
        "collaborative_filtering",  # 协同过滤
        "content_based",            # 内容过滤
        "knowledge_graph",          # 图谱推理
        "exploration"               # 探索（推荐新类型）
    ])

    # 推荐数量
    limit: int = 10

# 示例：开放推荐
evidence = RecommendationEvidence(
    user_profile={
        "favorite_genres": ["科幻", "悬疑"],
        "recently_watched": ["星际穿越"],
        "ratings": {"肖申克的救赎": 5}
    },
    constraints={"min_rating": 7.5},
    strategies=["content_based", "exploration"],
    limit=10
)

# 示例：场景推荐
evidence = RecommendationEvidence(
    scenario="周末放松",
    constraints={
        "mood": "轻松",
        "max_duration": 120,
        "family_friendly": True
    },
    strategies=["scenario_based", "content_based"],
    limit=10
)
```

### 3.3 输出结构

```python
@dataclass
class RecommendationOutput:
    """推荐的输出结构"""

    # 查询理解
    query_understanding: Dict[str, Any]
    """
    {
        "query_type": "recommendation",
        "has_user_profile": true,
        "scenario": "周末放松",
        "constraints": {"mood": "轻松", "max_duration": 120}
    }
    """

    # 推荐列表（核心输出）
    recommendations: List[Dict[str, Any]]
    """
    [
        {
            "rank": 1,
            "movie": {
                "title": "寻梦环游记",
                "year": 2017,
                "rating": 9.1,
                "duration": 105,
                "genres": ["动画", "奇幻", "音乐"]
            },

            # 推荐理由（必须）
            "reason": {
                "type": "content_based",
                "explanation": "因为你喜欢温情励志的电影（评分《肖申克的救赎》5星）",
                "match_factors": ["同类型：剧情", "同主题：希望", "高评分"],
                "confidence": 0.92
            },

            # 匹配度
            "match_score": 0.95,

            # 场景匹配
            "scenario_match": {
                "mood": "温馨治愈",
                "family_friendly": true,
                "weekend_suitable": true
            }
        },
        {
            "rank": 2,
            "movie": {
                "title": "玩具总动员3",
                "year": 2010,
                "rating": 8.3,
                "duration": 103
            },
            "reason": {
                "type": "collaborative_filtering",
                "explanation": "喜欢《肖申克的救赎》的用户也喜欢这部",
                "similar_users": 1234,
                "confidence": 0.85
            },
            "match_score": 0.88
        },
        {
            "rank": 3,
            "movie": {
                "title": "机器人总动员",
                "year": 2008,
                "rating": 8.6,
                "duration": 98
            },
            "reason": {
                "type": "exploration",
                "explanation": "尝试不同类型的动画电影，同样温馨治愈",
                "novelty": "高（探索动画类型）",
                "confidence": 0.70
            },
            "match_score": 0.75
        }
    ]
    """

    # 策略说明
    strategy_summary: Dict[str, Any]
    """
    {
        "strategies_used": ["content_based", "collaborative_filtering", "exploration"],
        "distribution": {
            "content_based": 5,      # 5部基于内容
            "collaborative": 3,      # 3部协同过滤
            "exploration": 2         # 2部探索新类型
        },
        "personalization_applied": true,
        "exclusions_applied": ["已看过的3部", "不想看的恐怖片"]
    }
    """

    # 多样性说明
    diversity: Dict[str, Any]
    """
    {
        "genre_distribution": {"动画": 4, "剧情": 3, "喜剧": 3},
        "year_distribution": {"1990s": 2, "2000s": 3, "2010s": 5},
        "mood_distribution": {"温馨": 6, "轻松": 4}
    }
    """

# JSON输出示例
{
    "query_understanding": {
        "query_type": "recommendation",
        "scenario": "周末放松",
        "has_user_profile": true
    },
    "recommendations": [
        {
            "rank": 1,
            "movie": {
                "title": "寻梦环游记",
                "year": 2017,
                "rating": 9.1
            },
            "reason": {
                "type": "content_based",
                "explanation": "因为你喜欢温情励志的电影",
                "match_factors": ["同类型", "同主题"]
            },
            "match_score": 0.95
        }
    ],
    "strategy_summary": {
        "strategies_used": ["content_based", "exploration"],
        "distribution": {"content_based": 7, "exploration": 3}
    }
}
```

### 3.4 实现策略

```python
# Agent选择：PersonalizedRecAgent（新建）
# 检索策略：用户画像 + 多策略推荐算法

class PersonalizedRecAgent(BaseAgent):
    def retrieve_with_trace(self, query: str) -> RecommendationOutput:
        # Step 1: 解析查询
        parsed = self.parse_recommendation_query(query)
        # -> {"type": "scenario_based", "scenario": "周末放松"}

        # Step 2: 获取用户画像
        user_profile = self.get_user_profile(parsed["user_id"])

        # Step 3: 场景识别
        scenario = self.identify_scenario(parsed)  # "周末放松"
        scenario_constraints = self.map_scenario_to_constraints(scenario)
        # -> {"mood": "轻松", "max_duration": 120, "family_friendly": true}

        # Step 4: 多策略推荐
        recommendations = []

        # 策略1: 基于内容
        content_based = self.content_based_filtering(
            user_profile,
            scenario_constraints
        )
        recommendations.extend(content_based[:5])

        # 策略2: 协同过滤
        collab = self.collaborative_filtering(
            user_profile,
            scenario_constraints
        )
        recommendations.extend(collab[:3])

        # 策略3: 图谱推理
        kg_rec = self.kg_reasoning(
            user_profile,
            scenario_constraints
        )
        recommendations.extend(kg_rec[:1])

        # 策略4: 探索（推荐新类型）
        exploration = self.exploration(
            user_profile,
            scenario_constraints
        )
        recommendations.extend(exploration[:1])

        # Step 5: 去重和排序
        unique_recs = self.deduplicate(recommendations)
        ranked = self.rank_by_match_score(unique_recs, user_profile, scenario)

        # Step 6: 多样性调整（避免同类电影过于集中）
        diversified = self.diversify(ranked)

        # Step 7: 生成推荐理由
        for rec in diversified:
            rec["reason"] = self.generate_recommendation_reason(
                rec, user_profile, scenario
            )

        return RecommendationOutput(
            recommendations=diversified[:10],
            strategy_summary=self.summarize_strategies(diversified),
            diversity=self.compute_diversity(diversified)
        )
```

---

## 类型 4：比较/选择

### 4.1 触发模式
**用户意图**：对比两部或多部电影，帮助决策

**问题示例**：
- "《星际穿越》和《2001太空漫游》哪个更好？"
- "诺兰三部曲和后来的《蝙蝠侠》重启版有什么区别？"
- "《流浪地球》和《星际穿越》科幻观差异"
- "适合新人的诺兰电影入门推荐"
- "漫威和DC超级英雄电影对比"

**关键词特征**：
```python
COMPARISON_PATTERNS = [
    r"(.*?)和(.*?)哪个(更好|值得看)",
    r"(.*?)vs(.*?)",
    r"(.*?)和(.*?)的区别",
    r"(.*?)和(.*?)对比",
    r"(.*?)入门推荐",
    r"(.*?)片单"
]

COMPARISON_DIMENSIONS = [
    "rating", "story", "visual_effects", "scientific_accuracy",
    "tone", "target_audience", "box_office", "influence"
]
```

### 4.2 证据需求

```python
@dataclass
class ComparisonEvidence:
    """比较的证据需求"""

    # 必需：比较对象（电影/系列/导演）
    subjects: List[Dict[str, Any]]
    """
    [
        {"title": "星际穿越", "year": 2014, "id": "movie_123"},
        {"title": "2001太空漫游", "year": 1968, "id": "movie_456"}
    ]
    """

    # 比较类型
    comparison_type: Literal["two_movies", "franchise", "list"]

    # 比较维度（自动推断）
    dimensions: List[str]
    """
    ["rating", "story", "visual_effects", "scientific_accuracy",
     "tone", "philosophical_depth", "era"]
    """

    # 比较目的
    purpose: Optional[str] = None
    """
    "选择观看", "了解差异", "入门推荐"
    """

# 示例：两部电影对比
evidence = ComparisonEvidence(
    subjects=[
        {"title": "星际穿越", "year": 2014},
        {"title": "2001太空漫游", "year": 1968}
    ],
    comparison_type="two_movies",
    dimensions=["rating", "story", "visual_effects", "era", "tone"]
)
```

### 4.3 输出结构

```python
@dataclass
class ComparisonOutput:
    """比较的输出结构"""

    # 查询理解
    query_understanding: Dict[str, Any]
    """
    {
        "subjects": ["星际穿越", "2001太空漫游"],
        "comparison_type": "two_movies",
        "purpose": "选择观看"
    }
    """

    # 对比表（核心输出）
    comparison_table: Dict[str, Any]
    """
    {
        "dimensions": ["评分", "叙事", "视觉", "时代", "主题"],
        "rows": [
            {
                "dimension": "评分",
                "星际穿越": {"value": 8.6, "label": "IMDb"},
                "2001太空漫游": {"value": 8.3, "label": "IMDb"},
                "winner": "星际穿越"
            },
            {
                "dimension": "叙事风格",
                "星际穿越": {"value": "情感驱动，父女线", "label": ""},
                "2001太空漫游": {"value": "哲学抽象，晦涩", "label": ""},
                "winner": "取决于偏好"
            },
            {
                "dimension": "视觉效果",
                "星际穿越": {"value": "科学真实感", "label": ""},
                "2001太空漫游": {"value": "开创性，经典", "label": ""},
                "winner": "2001太空漫游（历史地位）"
            },
            {
                "dimension": "科学性",
                "星际穿越": {"value": "基于理论物理", "label": ""},
                "2001太空漫游": {"value": "更具预言性", "label": ""},
                "winner": "平局"
            },
            {
                "dimension": "时代背景",
                "星际穿越": {"value": "21世纪，关注气候", "label": ""},
                "2001太空漫游": {"value": "1968年，冷战思维", "label": ""},
                "winner": "-"
            }
        ]
    }
    """

    # 相似点
    similarities: List[Dict[str, str]]
    """
    [
        {
            "dimension": "主题",
            "description": "都探讨人类在宇宙中的位置",
            "examples": ["太空探索", "人工智能", "人类进化"]
        },
        {
            "dimension": "视觉风格",
            "description": "都强调科学真实感和视觉震撼"
        }
    ]
    """

    # 不同点
    differences: List[Dict[str, Any]]
    """
    [
        {
            "dimension": "叙事方式",
            "星际穿越": "情感驱动，父女情感线",
            "2001太空漫游": "哲学驱动，抽象晦涩"
        },
        {
            "dimension": "时代背景",
            "星际穿越": "21世纪视角，关注气候变化",
            "2001太空漫游": "冷战时期，关注人工智能威胁"
        }
    ]
    """

    # 结论建议
    verdict: Dict[str, Any]
    """
    {
        "subjective": "两者各有特色，选择取决于个人偏好",
        "recommendation": {
            "喜欢情感叙事": "星际穿越",
            "喜欢哲学思辨": "2001太空漫游",
            "看重视觉效果历史地位": "2001太空漫游",
            "追求科学真实感": "星际穿越"
        },
        "watch_order": "建议都看，先看《2001太空漫游》理解经典，再看《星际穿越》感受现代诠释"
    }
    """

# JSON输出示例
{
    "query_understanding": {
        "subjects": ["星际穿越", "2001太空漫游"],
        "comparison_type": "two_movies"
    },
    "comparison_table": {
        "dimensions": ["评分", "叙事", "视觉", "科学性", "时代"],
        "星际穿越": {
            "评分": 8.6,
            "叙事": "情感驱动",
            "视觉": "科学真实感",
            "科学性": "理论物理",
            "时代": "21世纪"
        },
        "2001太空漫游": {
            "评分": 8.3,
            "叙事": "哲学抽象",
            "视觉": "开创性",
            "科学性": "预言性",
            "时代": "1968年"
        }
    },
    "similarities": [
        {"dimension": "主题", "description": "都探讨人类在宇宙中的位置"}
    ],
    "differences": [
        {
            "dimension": "叙事方式",
            "星际穿越": "情感驱动",
            "2001太空漫游": "哲学驱动"
        }
    ],
    "verdict": {
        "subjective": "两者各有特色",
        "recommendation": {
            "喜欢情感叙事": "星际穿越",
            "喜欢哲学思辨": "2001太空漫游"
        }
    }
}
```

### 4.4 实现策略

```python
# Agent选择：MovieQAAgent（对比模式）
# 检索策略：双实体检索 + 多维度对比分析

class ComparisonAgent(BaseAgent):
    def retrieve_with_trace(self, query: str) -> ComparisonOutput:
        # Step 1: 解析查询
        parsed = self.parse_comparison_query(query)
        # -> {"subjects": ["星际穿越", "2001太空漫游"], "type": "two_movies"}

        # Step 2: 识别比较对象
        subjects = [self.identify_movie(s) for s in parsed["subjects"]]

        # Step 3: 推断比较维度
        dimensions = self.infer_dimensions(parsed, subjects)
        # -> ["rating", "story", "visual_effects", "era", "tone"]

        # Step 4: 检索每个对象在各维度的信息
        comparison_data = {}
        for subject in subjects:
            comparison_data[subject["title"]] = self.retrieve_movie_dimensions(
                subject, dimensions
            )

        # Step 5: 构建对比表
        comparison_table = self.build_comparison_table(
            subjects, dimensions, comparison_data
        )

        # Step 6: 分析相似点
        similarities = self.analyze_similarities(subjects, comparison_data)

        # Step 7: 分析不同点
        differences = self.analyze_differences(subjects, comparison_data)

        # Step 8: 生成结论建议
        verdict = self.generate_verdict(similarities, differences, parsed.get("purpose"))

        return ComparisonOutput(
            comparison_table=comparison_table,
            similarities=similarities,
            differences=differences,
            verdict=verdict
        )
```

---

## 类型 5：解释/深聊

### 5.1 触发模式
**用户意图**：深度分析、风格解读、影史脉络

**问题示例**：
- "诺兰电影的共同特点是什么？"
- "《盗梦空间》的结局是什么意思？"
- "为什么《肖申克的救赎》能成为经典？"
- "法国新浪潮电影对后世的影响"
- "漫威电影宇宙的时间线是怎样的？"

**关键词特征**：
```python
DEEP_ANALYSIS_PATTERNS = [
    r"(.*?)的(风格|特点|主题)",
    r"(.*?)为什么(好|经典|成功)",
    r"(.*?)的(结局|含义)是什么",
    r"(.*?)对(后世|影响)",
    r"(.*?)的(发展|演变)"
]

ANALYSIS_TYPES = [
    "style_analysis",      # 风格分析
    "plot_interpretation", # 剧情解读
    "thematic_analysis",   # 主题分析
    "historical_context",  # 历史背景
    "influence_analysis",  # 影响分析
    "canon_analysis"       # 脉络梳理
]
```

### 5.2 证据需求

```python
@dataclass
class DeepAnalysisEvidence:
    """深度分析的证据需求"""

    # 分析对象
    subject: Dict[str, Any]
    """
    {"name": "诺兰", "type": "director"}
    或 {"name": "盗梦空间", "type": "movie"}
    """

    # 分析类型
    analysis_type: str
    """
    "style_analysis", "plot_interpretation", "thematic_analysis",
    "historical_context", "influence_analysis", "canon_analysis"
    """

    # 需要多源信息
    sources_required: List[str]
    """
    ["kg", "reviews", "interviews", "essays", "community_discussions"]
    """

    # 检索深度
    retrieval_depth: Literal["shallow", "medium", "deep"]
    """
    - shallow: 1-2跳关系
    - medium: 3-5跳关系 + 多源聚合
    - deep: 5+跳关系 + 深度推理
    """

    # 结构化论证要求
    require_structured_argumentation: bool = True

# 示例：诺兰风格分析
evidence = DeepAnalysisEvidence(
    subject={"name": "克里斯托弗·诺兰", "type": "director"},
    analysis_type="style_analysis",
    sources_required=["kg", "reviews", "interviews", "essays"],
    retrieval_depth="medium",
    require_structured_argumentation=True
)
```

### 5.3 输出结构

```python
@dataclass
class DeepAnalysisOutput:
    """深度分析的输出结构"""

    # 查询理解
    query_understanding: Dict[str, Any]
    """
    {
        "subject": "诺兰电影",
        "analysis_type": "style_analysis",
        "depth": "medium"
    }
    """

    # 核心论点（结构化）
    thesis: str
    """
    "诺兰电影以非线性叙事、时间概念探索和哲学思辨为核心风格，
    通过复杂的叙事结构和视觉语言探讨记忆、时间、身份等主题。"
    """

    # 论证结构（多段）
    arguments: List[Dict[str, Any]]
    """
    [
        {
            "section_id": 1,
            "title": "非线性叙事结构",
            "points": [
                {
                    "claim": "诺兰偏爱非线性叙事",
                    "evidence": [
                        "《盗梦空间》的多层梦境时间线",
                        "《记忆碎片》的倒叙结构",
                        "《敦刻尔克》的三条时间线"
                    ],
                    "examples": [
                        {"movie": "盗梦空间", "description": "多层梦境，时间流速不同"},
                        {"movie": "记忆碎片", "description": "彩色/黑白倒叙并行"}
                    ],
                    "sources": [
                        {"type": "kg", "description": "电影叙事结构数据"},
                        {"type": "review", "author": "影评人XXX"}
                    ]
                }
            ]
        },
        {
            "section_id": 2,
            "title": "时间概念的探索",
            "points": [
                {
                    "claim": "时间成为诺兰电影的标志性元素",
                    "evidence": [
                        "《致命魔术》的双重时间线",
                        "《盗梦空间》的梦境时间",
                        "《星际穿越》的相对论时间膨胀",
                        "《信条》的时间逆转",
                        "《奥本海默》的非线性叙事"
                    ],
                    "reasoning": "诺兰多部作品围绕时间概念展开",
                    "kg_paths": [
                        "诺兰 → 致命魔术 → 时间主题",
                        "诺兰 → 盗梦空间 → 时间主题",
                        "诺兰 → 星际穿越 → 时间主题"
                    ],
                    "sources": [
                        {"type": "kg", "path": "多跳查询归纳"},
                        {"type": "interview", "author": "诺兰本人访谈"}
                    ]
                }
            ]
        },
        {
            "section_id": 3,
            "title": "哲学思辨主题",
            "points": [
                {
                    "claim": "诺兰电影探讨深刻的哲学命题",
                    "evidence": [
                        "《盗梦空间》：现实与梦境界限",
                        "《星际穿越》：爱与科学的辩证",
                        "《黑暗骑士》：秩序与混沌",
                        "《信条》：因果律与宿命论"
                    ],
                    "sources": [
                        {"type": "essay", "title": "诺兰电影的哲学解读"}
                    ]
                }
            ]
        }
    ]
    """

    # 结论
    conclusion: str
    """
    "综上所述，诺兰通过非线性叙事、时间概念和哲学思辨，
    形成了独特的电影风格，被称为'时间的魔术师'..."
    """

    # 相关推荐（延伸阅读）
    further_reading: List[Dict[str, str]]
    """
    [
        {"type": "similar_director", "title": "维伦纽瓦的科幻哲学"},
        {"type": "essay", "title": "诺兰电影的叙事学分析"}
    ]
    """

# JSON输出示例
{
    "query_understanding": {
        "subject": "诺兰电影",
        "analysis_type": "style_analysis"
    },
    "thesis": "诺兰电影以非线性叙事、时间概念探索和哲学思辨为核心风格",
    "arguments": [
        {
            "section_id": 1,
            "title": "非线性叙事结构",
            "points": [
                {
                    "claim": "诺兰偏爱非线性叙事",
                    "evidence": ["《盗梦空间》多层梦境", "《记忆碎片》倒叙"],
                    "sources": [{"type": "kg"}]
                }
            ]
        },
        {
            "section_id": 2,
            "title": "时间概念的探索",
            "points": [
                {
                    "claim": "时间成为诺兰电影的标志性元素",
                    "evidence": ["致命魔术", "盗梦空间", "星际穿越", "信条"],
                    "kg_paths": ["诺兰 → 多部电影 → 时间主题"],
                    "sources": [{"type": "kg", "path": "多跳归纳"}]
                }
            ]
        }
    ],
    "conclusion": "诺兰被称为'时间的魔术师'..."
}
```

### 5.4 实现策略

```python
# Agent选择：MovieQAAgent（深度研究模式）
# 检索策略：多跳查询 + 多源聚合 + 结构化论证

class DeepAnalysisAgent(BaseAgent):
    def retrieve_with_trace(self, query: str) -> DeepAnalysisOutput:
        # Step 1: 解析查询
        parsed = self.parse_deep_analysis_query(query)
        # -> {"subject": "诺兰", "analysis_type": "style_analysis"}

        # Step 2: 识别分析对象
        subject = self.identify_subject(parsed["subject"])

        # Step 3: 确定检索深度
        depth = self.determine_depth(parsed["analysis_type"])
        # -> "medium" (3-5跳关系)

        # Step 4: 多源信息检索
        evidence = {}
        for source_type in ["kg", "reviews", "interviews", "essays"]:
            evidence[source_type] = self.retrieve_from_source(
                subject, parsed["analysis_type"], source_type, depth
            )

        # Step 5: 构建论证结构
        thesis = self.generate_thesis(subject, parsed["analysis_type"], evidence)

        # Step 6: 组织论证段落
        arguments = []
        for section_id, section_theme in enumerate(self.extract_themes(evidence), 1):
            points = self.build_arguments(
                section_theme, evidence[section_id], subject
            )
            arguments.append({
                "section_id": section_id,
                "title": section_theme,
                "points": points
            })

        # Step 7: 生成结论
        conclusion = self.generate_conclusion(thesis, arguments)

        # Step 8: 延伸阅读推荐
        further_reading = self.recommend_further_reading(subject, arguments)

        return DeepAnalysisOutput(
            thesis=thesis,
            arguments=arguments,
            conclusion=conclusion,
            further_reading=further_reading
        )
```

---

## 类型 6：会话内指代

### 6.1 触发模式
**用户意图**：指代上下文中的对象

**问题示例**：
- "刚才那部电影的导演是谁？"（指代上一轮提到的电影）
- "第二个的评分是多少？"（指代上一轮列表中的第2项）
- "这类电影还有吗？"（指代上一轮讨论的类型）
- "他还有哪些作品？"（"他"指代上一轮提到的人）

**关键词特征**：
```python
COREFERENCE_PATTERNS = [
    r"刚才那部(电影|人)",
    r"第(二|三|几)个",
    r"这(类|种)",
    r"他(她|它)还有",
    r"还有(类似的|同类型的)",
    r"再推荐几部"
]

COREFERENCE_TYPES = [
    "movie",           # 指代电影
    "person",          # 指代人物
    "genre",           # 指代类型
    "list_item",       # 指代列表项
    "recommendation"   # 指代推荐集合
]
```

### 6.2 证据需求

```python
@dataclass
class CoreferenceEvidence:
    """指代消解的证据需求"""

    # 当前查询
    current_query: str

    # 对话历史
    conversation_history: List[Dict[str, Any]]
    """
    [
        {
            "role": "user",
            "content": "诺兰导演过哪些电影？",
            "timestamp": "2024-01-20T10:00:00",
            "entities": ["诺兰"],
            "response_entities": ["致命魔术", "盗梦空间", "星际穿越", ...]
        },
        {
            "role": "assistant",
            "content": "诺兰导演过12部电影，包括...",
            "timestamp": "2024-01-20T10:00:05",
            "mentioned_movies": ["致命魔术", "盗梦空间", "星际穿越", ...]
        }
    ]
    """

    # 对话总结（短期记忆）
    conversation_summary: Optional[str] = None
    """
    "用户询问诺兰的作品列表，系统返回了12部电影，
    按评分排序，前3名是盗梦空间、星际穿越、黑暗骑士"
    """

    # Episodic记忆（相关对话片段）
    episodic_memories: List[Dict[str, Any]]
    """
    [
        {
            "summary": "用户之前对诺兰电影表现出兴趣",
            "relevant_entities": ["诺兰", "科幻", "时间"],
            "timestamp": "2024-01-19T15:30:00"
        }
    ]
    """

    # 指代消解结果
    resolved_references: Dict[str, Any]
    """
    {
        "type": "movie",
        "reference": "第二个",
        "resolved_to": {
            "entity": "星际穿越",
            "position_in_list": 2,
            "context": "上一轮返回的第2部电影"
        }
    }
    """

# 示例
evidence = CoreferenceEvidence(
    current_query="第二个的评分是多少？",
    conversation_history=[
        {"role": "user", "content": "诺兰导演过哪些电影？"},
        {"role": "assistant", "content": "...", "mentioned_movies": ["致命魔术", "盗梦空间", "星际穿越"]}
    ],
    conversation_summary="用户询问诺兰作品，返回了按评分排序的列表",
    episodic_memories=[{"summary": "用户对诺兰电影感兴趣"}],
    resolved_references={
        "type": "list_item",
        "reference": "第二个",
        "resolved_to": {"entity": "盗梦空间", "position": 2}
    }
)
```

### 6.3 输出结构

```python
@dataclass
class CoreferenceOutput:
    """指代消解的输出结构"""

    # 指代消解结果
    resolution: Dict[str, Any]
    """
    {
        "original_query": "第二个的评分是多少？",
        "resolved_query": "《盗梦空间》的评分是多少？",
        "resolution_process": {
            "step_1": "识别指代类型：list_item",
            "step_2": "定位上下文：上一轮返回的电影列表",
            "step_3": "解析位置：'第二个' → position=2",
            "step_4": "消解引用：position=2 → 《盗梦空间》"
        },
        "resolved_entity": {
            "name": "盗梦空间",
            "year": 2010,
            "confidence": 0.98
        }
    }
    """

    # 对齐后的标准查询
    aligned_query: str
    """
    "《盗梦空间》（2010）的评分是多少？"
    """

    # 使用对齐查询的结果（复用其他类型的输出）
    result: Dict[str, Any]
    """
    {
        "type": "fact_query",
        "answer": "《盗梦空间》（2010）的IMDb评分是8.8...",
        "key_fields": {"imdb_rating": 8.8, "douban_rating": 9.3}
    }
    """

# JSON输出示例
{
    "resolution": {
        "original_query": "第二个的评分是多少？",
        "resolved_query": "《盗梦空间》的评分是多少？",
        "resolved_entity": {
            "name": "盗梦空间",
            "year": 2010,
            "position_in_list": 2
        }
    },
    "aligned_query": "《盗梦空间》（2010）的评分是多少？",
    "result": {
        "type": "fact_query",
        "answer": "《盗梦空间》的IMDb评分是8.8...",
        "key_fields": {"imdb_rating": 8.8}
    }
}
```

### 6.4 实现策略

```python
# Agent选择：CoreferenceResolver（前置处理）+ 其他Agent
# 检索策略：短期历史 + Summary + Episodic → 指代消解

class CoreferenceResolver:
    def resolve(self, query: str, context: ConversationContext) -> CoreferenceOutput:
        # Step 1: 检测指代
        if not self.has_coreference(query):
            return None  # 无指代，直接处理原查询

        # Step 2: 提取指代类型和目标
        reference = self.extract_reference(query)
        # -> {"type": "list_item", "target": "第二个"}

        # Step 3: 从对话历史中检索上下文
        if reference["type"] == "list_item":
            # 从上一轮的响应中提取列表
            last_response = context.conversation_history[-1]
            mentioned_items = last_response.get("mentioned_movies", [])

            # 解析位置
            position = self.parse_position(reference["target"])
            # -> 2

            # 消解引用
            resolved_entity = mentioned_items[position - 1]

        elif reference["type"] == "movie":
            # 从对话历史中找到最近提到的电影
            resolved_entity = self.find_recent_mention(
                context.conversation_history,
                entity_type="movie"
            )

        elif reference["type"] == "genre":
            # 从对话总结中提取类型
            resolved_entity = self.extract_from_summary(
                context.conversation_summary,
                entity_type="genre"
            )

        # Step 4: 构建对齐后的查询
        aligned_query = self.build_aligned_query(query, resolved_entity)

        # Step 5: 使用对齐查询调用相应Agent
        # （根据对齐后的查询类型，路由到相应Agent）
        result = self.route_and_execute(aligned_query, context)

        return CoreferenceOutput(
            resolution={
                "original_query": query,
                "resolved_query": aligned_query,
                "resolved_entity": resolved_entity
            },
            aligned_query=aligned_query,
            result=result
        )
```

---

## 总结：6大类问题的证据需求和输出结构

| 类型 | 触发关键词 | 证据需求 | 输出核心 | Agent |
|------|-----------|---------|---------|-------|
| **1. 事实查询** | 导演/年份/片长/评分 | 实体+属性 | 答案+关键字段+来源 | GraphAgent |
| **2. 人物相关** | 作品列表/代表作/合作 | 人物+关系 | filmography列表+统计 | GraphAgent |
| **3. 推荐** | 推荐/适合/好看 | 用户画像+约束 | 候选清单+推荐理由 | PersonalizedRecAgent |
| **4. 比较** | vs/对比/哪个好 | 双实体+维度 | 对比表+结论建议 | ComparisonAgent |
| **5. 解释深聊** | 风格/主题/影响 | 多源+多跳 | 结构化论证+引用 | DeepAnalysisAgent |
| **6. 指代消解** | 刚才/第二个/这类 | 历史上下文 | 对齐查询+标准结果 | CoreferenceResolver |

---

## 实施优先级

### P0 - 立即实现（核心价值）
1. ✅ **类型1：事实查询** - 已有基础
2. ✅ **类型2：人物相关** - 已有基础
3. 🟡 **类型6：指代消解** - 前置依赖

### P1 - 近期实现（差异化价值）
4. 🟡 **类型3：推荐** - 核心缺失
5. 🟡 **类型4：比较** - 中等难度

### P2 - 中期实现（锦上添花）
6. 🔴 **类型5：解释深聊** - 高级功能

---

## 下一步：技术实现

我建议按以下顺序实现：

**第1步：问题分类器**
```python
class QuestionClassifier:
    def classify(self, query: str, context: ConversationContext) -> QuestionType
```

**第2步：定义6大类型的Schema**
```python
# backend/domain/classification/schemas.py
- FactQueryEvidence / FactQueryOutput
- PersonQueryEvidence / PersonQueryOutput
- RecommendationEvidence / RecommendationOutput
- ComparisonEvidence / ComparisonOutput
- DeepAnalysisEvidence / DeepAnalysisOutput
- CoreferenceEvidence / CoreferenceOutput
```

**第3步：实现指代消解（优先级最高）**
```python
class CoreferenceResolver:
    def resolve(self, query: str, context: ConversationContext) -> AlignedQuery
```

**第4步：实现推荐Agent**
```python
class PersonalizedRecAgent:
    def retrieve_with_trace(self, query: str) -> RecommendationOutput
```

**第5步：测试用例**
为每类准备10-20个测试用例，验证分类和输出正确性。

---

需要我帮你开始实现哪个部分？
